#include "codegen.hpp"
#include "vm.hpp"
#include "emit.hpp"
#include "vfmath.hpp"

namespace vf
{
    using namespace std;

    /**
     * Constructor, performs initialization
     */
    Codegen::Codegen() : m_Sink(nullptr), m_MaxTempRegisters(0), m_TmpRegisterOffset(0)
    {
    }

    /*************************************************************************/
    /*                      Allocation of temporary registers                */
    /*************************************************************************/

    /**
     * Allocates a temporary registers.
     */
    uint8_t Codegen::NextTemporary(const Environment * pEnv)
    {
        if ((m_TmpRegisterOffset + 1) > m_MaxTempRegisters) {
            m_MaxTempRegisters = m_TmpRegisterOffset + 1;
        }
        return static_cast<uint8_t>(pEnv->GetNumRegisters() + m_TmpRegisterOffset++);
    }

    /**
     * Resets the number of active temporary registers.
     */
    void Codegen::ResetTempRegisters()
    {
        m_TmpRegisterOffset = 0;
    }

    /**
     * Returns the number of required temporary registers.
     */
    uint8_t Codegen::NumTemporaryRegisters() const
    {
        return m_MaxTempRegisters;
    }

    /**
     * Sets the codegeneration sink. Generated bytecode will be emitted to this sink.
     */
    Codegen & Codegen::SetSink(vf::IEmitSink & sink)
    {
        m_Sink = &sink;
        return *this;
    }

    /*************************************************************************/
    /*                                  Uniforms                             */
    /*************************************************************************/
    void Codegen::SetUniform(vf::SymbolTable::SymIndex symIndex, float fValue)
    {
        Vector & value  = m_Uniforms[symIndex];
        value.u.f       = fValue;
    }

    void Codegen::SetUniform(vf::SymbolTable::SymIndex symIndex, const vf::Vector2 & v2)
    {
        Vector & value  = m_Uniforms[symIndex];
        value.u.v2      = v2;
    }

    void Codegen::SetUniform(vf::SymbolTable::SymIndex symIndex, const vf::Vector3 & v3)
    {
        Vector & value  = m_Uniforms[symIndex];
        value.u.v3      = v3;
    }

    void Codegen::SetUniform(vf::SymbolTable::SymIndex symIndex, const vf::Vector4 & v4)
    {
        Vector & value  = m_Uniforms[symIndex];
        value.u.v4      = v4;
    }

    bool Codegen::GetUniform(vf::SymbolTable::SymIndex symIndex, vf::Vector & value) const
    {
        std::map<vf::SymbolTable::SymIndex, vf::Vector>::const_iterator vec =
            m_Uniforms.find(symIndex);
        if (vec == m_Uniforms.end()) {
            return false;
        }
        value = vec->second;
        return true;
    }

    /*************************************************************************/
    /*                                  Compilation                          */
    /*************************************************************************/
    /**
     * Compiles a function to a byte code representation.
     * 
     * \param       pFunc       The function to compile.
     * \param       pEnv        The current environment.
     */
    bool Codegen::Compile(std::shared_ptr<vf::Node_Function> pFunc, vf::Environment * pEnv)
    {
        pEnv = pEnv->GetEnvironment(pFunc->m_Name);
        if (!pEnv) {
            return false;
        }

        for(vector<shared_ptr<Node_Statement> >::const_iterator it = pFunc->m_pStatements.begin(); 
            it != pFunc->m_pStatements.end();
            it++)
        {
            ResetTempRegisters();
            if (!Compile(*reinterpret_cast<vf::Node_Assignment*>((it->get())), pEnv)) {
                return false;
            }
        }

        return true;
    }

    /**
     * Generates bytecode for a assignment.
     */
    bool Codegen::Compile(const vf::Node_Assignment & stmt, vf::Environment * pEnv)
    {
        uint8_t varReg, varIndex;
        bool accumulated = false;

        if (!stmt.m_pIdentifier) { // Used for local variables
            vf::Variable ident;
            if (!pEnv->Lookup(stmt.m_Name, ident)) {
                return false;
            }
            varReg      = ident.m_Register;
            varIndex    = 0;
        } else { // used for normal variables
            ExpInfo var;
            if (!Compile(stmt.m_pIdentifier.get(), pEnv, var)) {
                return false;
            }
            varReg      = var.reg;
            varIndex    = var.regidx;
            accumulated = var.isaccumulated ? true : false;
        }

        ExpInfo exp;
        if (accumulated) {
            /** Add the result of the operation to a output register */
            if (!Compile(stmt.m_pExpression.get(), pEnv, exp)) {
                return false;
            }
            ExpInfo lhs;
            lhs.reg     = varReg;
            lhs.regidx  = varIndex;
            lhs.type    = exp.type;
            return emit_add(m_Sink, varReg, varIndex, lhs, exp);
        } else { // generate code for a normal assignment.
            if (!Compile(stmt.m_pExpression.get(), pEnv, exp, varReg, varIndex)) {
                return false;
            }
            if (exp.isconst || (exp.reg != varReg) || (exp.regidx != varIndex) || exp.isuniform) {
                return emit_assign(m_Sink, varReg, varIndex, exp);
            }
        }
        return true;
    }

    /**
     * Compiles a expression to bytecode.
     * \param       exp     The expression to compile.
     * \param       pEnv    The execution environment.
     * \param       info    Information about the resulting expression.
     * \param       reg     In which register the result should be placed.
     * \param       offset  The offset in the register to store the scalar result.
     */
    bool Codegen::Compile(const Node_Expression * exp, Environment * pEnv, ExpInfo & info,VM_Register_t reg, int offset)
    {
        switch(exp->Type())
        {
        case Node_Expression::EXP_CONSTANT:         return Compile(*(const Node_Constant *)exp, pEnv, info, reg, offset);
        case Node_Expression::EXP_IDENTIFIER:       return Compile(*(const Node_Identifier *)exp, pEnv, info, reg, offset);
        case Node_Expression::EXP_MEMBER_REFERENCE: return Compile(*(const Node_MemberReference *)exp , pEnv, info, reg, offset);
        case Node_Expression::EXP_BINARY:           return Compile(*(const Node_Binary*)exp, pEnv, info, reg, offset);
        case Node_Expression::EXP_CONDITIONAL:      return Compile(*(const Node_Conditional*)exp, pEnv, info, reg, offset);
        case Node_Expression::EXP_DOT:              return Compile(*(const Node_DotProduct*)exp, pEnv, info, reg, offset);
        case Node_Expression::EXP_CROSS:            return Compile(*(const Node_CrossProduct*)exp, pEnv, info, reg, offset);
        case Node_Expression::EXP_LENGTH:           return Compile(*(const Node_Length*)exp, pEnv, info, reg, offset);
        case Node_Expression::EXP_SIN:              return Compile(*(const Node_Sine*)exp, pEnv, info, reg, offset);
        case Node_Expression::EXP_COS:              return Compile(*(const Node_Cosine*)exp, pEnv, info, reg, offset);
        case Node_Expression::EXP_TAN:              return Compile(*(const Node_Tangent*)exp, pEnv, info, reg, offset);
        case Node_Expression::EXP_ASIN:             return Compile(*(const Node_ArcSine*)exp, pEnv, info, reg, offset);
        case Node_Expression::EXP_ACOS:             return Compile(*(const Node_ArcCosine*)exp, pEnv, info, reg, offset);
        case Node_Expression::EXP_ATAN:             return Compile(*(const Node_ArcTangent*)exp, pEnv, info, reg, offset);
        case Node_Expression::EXP_NEGATE:           return Compile(*(const Node_Negate*)exp, pEnv, info, reg, offset);
        case Node_Expression::EXP_SQRT:             return Compile(*(const Node_Sqrt*)exp, pEnv, info, reg, offset);
        case Node_Expression::EXP_INVSQRT:          return Compile(*(const Node_InvSqrt*)exp, pEnv, info, reg, offset);
        case Node_Expression::EXP_NORMALIZE:        return Compile(*(const Node_Normalize*)exp, pEnv, info, reg, offset);
        case Node_Expression::EXP_SAMPLER:          return Compile(*(const Node_Sampler*)exp, pEnv, info, reg, offset);
        case Node_Expression::EXP_MIN_MAX:          return Compile(*(const Node_MinMax*)exp, pEnv, info, reg, offset);
        case Node_Expression::EXP_FLOOR_CEIL:       return Compile(*(const Node_FloorCeil*)exp, pEnv, info, reg, offset);
        case Node_Expression::EXP_COMPARE:          return Compile(*(const Node_Comparison*)exp, pEnv);
        default:                                    return false;
        }
    }

    /*************************************************************************/
    /*                              Binary operations                        */
    /*************************************************************************/

    /**
     * Compiles a binary expression to the corresponding Virtual Machine byte code.
     */
    bool Codegen::Compile
        (
        const vf::Node_Binary & binary, 
        vf::Environment * pEnv, 
        vf::ExpInfo & info,
        VM_Register_t reg, 
        int offset
        )
    {
        switch(binary.m_Type)
        {
        case Node_Binary::Op_Add:   return Compile_Add(binary, pEnv, info, reg, offset);
        case Node_Binary::Op_Sub:   return Compile_Sub(binary, pEnv, info, reg, offset);
        case Node_Binary::Op_Mul:   return Compile_Mul(binary, pEnv, info, reg, offset);
        case Node_Binary::Op_Div:   return Compile_Div(binary, pEnv, info, reg, offset);
        default:                    return false;
        }
    }

    /**
     * Compiles a binary addition operation to the corresponding byte code.
     *
     * \param [in]      binary      The node representing the operation.
     * \param [in]      pEnv        The current environment.
     * \param [out]     info        Information about the generated expression.
     * \param [in]      reg         The register to store the result in, or VM_ANY_REGISTER
     *                              if a new temporary register needs to be allocated.
     * \param [in]      offset      Element offset in register, tells us where to store the result
     *                              of a scalar component.
     */
    bool Codegen::Compile_Add(const Node_Binary & binary, Environment * pEnv, ExpInfo & info,
        VM_Register_t reg, int offset)
    {
        ExpInfo left, right;
        if (!Compile(binary.m_pLeft.get(), pEnv, left) || !Compile(binary.m_pRight.get(), pEnv, right)) {
            return false;
        }
        if (left.type != right.type) {
            return false;
        }

        info.isconst    = left.isconst && right.isconst;
        info.type       = left.type;

        if (info.isconst) {     /** Both subexpressions are constant, perform constant folding */
            switch(info.type) {
                case vf::Type_Vec4:     info.value.u.v4 = left.value.u.v4 + right.value.u.v4; break;
                case vf::Type_Vec3:     info.value.u.v3 = left.value.u.v3 + right.value.u.v3; break;
                case vf::Type_Vec2:     info.value.u.v2 = left.value.u.v2 + right.value.u.v2; break;
                case vf::Type_Float:    info.value.u.f  = left.value.u.f + right.value.u.f; break;
            }
        } else {
            if (reg == VM_ANY_REGISTER) {
                reg             = left.isreusable ? left.reg : (right.isreusable ? right.reg : NextTemporary(pEnv));
                info.isreusable = 1;

            }
            info.reg        = reg;
            info.regidx     = offset;
            return emit_add(m_Sink, reg, offset, left, right);
        }
        return true;
    }

    /**
     * Compiles a binary addition operation to the corresponding byte code.
     *
     * \param [in]      binary      The node representing the operation.
     * \param [in]      pEnv        The current environment.
     * \param [out]     info        Information about the generated expression.
     * \param [in]      reg         The register to store the result in, or VM_ANY_REGISTER
     *                              if a new temporary register needs to be allocated.
     * \param [in]      offset      Element offset in register, tells us where to store the result
     *                              of a scalar component.
     */
    bool Codegen::Compile_Sub(const Node_Binary & binary, Environment * pEnv, ExpInfo & info,
        VM_Register_t reg, int offset)

    {
        ExpInfo left, right;
        if (!Compile(binary.m_pLeft.get(), pEnv, left) || !Compile(binary.m_pRight.get(), pEnv, right)) {
            return false;
        }
        if (left.type != right.type) {
            return false;
        }

        info.isconst    = left.isconst && right.isconst;
        info.type       = left.type;

        if (info.isconst) {
            switch(info.type) {
                case vf::Type_Vec4:     info.value.u.v4 = left.value.u.v4 - right.value.u.v4; break;
                case vf::Type_Vec3:     info.value.u.v3 = left.value.u.v3 - right.value.u.v3; break;
                case vf::Type_Vec2:     info.value.u.v2 = left.value.u.v2 - right.value.u.v2; break;
                case vf::Type_Float:    info.value.u.f  = left.value.u.f - right.value.u.f; break;
            }
        } else {
            if (reg == VM_ANY_REGISTER) {
                reg             = left.isreusable ? left.reg : 
                    (right.isreusable ? right.reg : NextTemporary(pEnv));
                info.isreusable = 1;
            }
            info.reg        = reg;
            info.regidx     = offset;
            return emit_sub(m_Sink, reg, offset, left, right);
        }
        return true;
    }

    /**
     * Divide a scalar/vector with a scalar.
     *
     * \param [in]      binary      The node representing the operation.
     * \param [in]      pEnv        The current environment.
     * \param [out]     info        Information about the generated expression.
     * \param [in]      reg         The register to store the result in, or VM_ANY_REGISTER
     *                              if a new temporary register needs to be allocated.
     * \param [in]      offset      Element offset in register, tells us where to store the result
     *                              of a scalar component.
     */
    bool Codegen::Compile_Div(const Node_Binary & binary, Environment * pEnv, ExpInfo & info, 
        VM_Register_t reg, int offset)

    {
        ExpInfo left, right;
        if (!Compile(binary.m_pLeft.get(), pEnv, left) || !Compile(binary.m_pRight.get(), pEnv, right)) {
            return false;
        }
        /** the right hand side expression is always a float */
        if (right.type != vf::Type_Float) {
            return false;
        }

        info.isconst    = left.isconst && right.isconst;
        info.type       = left.type;

        if (info.isconst) {
            switch(info.type) {
            case vf::Type_Vec4:     info.value.u.v4 = left.value.u.v4 / right.value.u.f; break;
            case vf::Type_Vec3:     info.value.u.v3 = left.value.u.v3 / right.value.u.f; break;
            case vf::Type_Vec2:     info.value.u.v2 = left.value.u.v2 / right.value.u.f; break;
            case vf::Type_Float:    info.value.u.f  = left.value.u.f / right.value.u.f; break;
            }
        } else {
            if (reg == VM_ANY_REGISTER) {
                reg = left.isreusable ? left.reg : (right.isreusable ? right.reg : NextTemporary(pEnv));
                info.isreusable = 1;
            }
            info.reg        = reg;
            info.regidx     = offset;
            return emit_div(m_Sink, reg, offset, left, right);
        }
        return true;
    }

    /*
     * Compiles a multiplication expression.
     *
     * \param [in]      binary      The node representing the operation.
     * \param [in]      pEnv        The current environment.
     * \param [out]     info        Information about the generated expression.
     * \param [in]      reg         The register to store the result in, or VM_ANY_REGISTER
     *                              if a new temporary register needs to be allocated.
     * \param [in]      offset      Element offset in register, tells us where to store the result
     *                              of a scalar component.
     */
    bool Codegen::Compile_Mul(const vf::Node_Binary & binary, Environment * pEnv, ExpInfo & info, VM_Register_t reg, int offset)
    {
        ExpInfo left, right;
        if (!Compile(binary.m_pLeft.get(), pEnv, left) || !Compile(binary.m_pRight.get(), pEnv, right)) {
            return false;
        }
        /** the right hand side expression is always a float */
        if (right.type != vf::Type_Float) {
            return false;
        }

        info.isconst    = left.isconst && right.isconst;
        info.type       = left.type;

        if (info.isconst) {
            switch(info.type) {
            case vf::Type_Vec4:     info.value.u.v4 = right.value.u.v4 * left.value.u.f; break;
            case vf::Type_Vec3:     info.value.u.v3 = right.value.u.v3 * left.value.u.f; break;
            case vf::Type_Vec2:     info.value.u.v2 = right.value.u.v2 * left.value.u.f; break;
            case vf::Type_Float:    info.value.u.f  = right.value.u.f * left.value.u.f; break;
            }
        } else {
            if (reg == VM_ANY_REGISTER) { 
                reg = left.isreusable ? left.reg : (right.isreusable ? right.reg : NextTemporary(pEnv));
                info.isreusable = 1;
            }
            info.reg        = reg;
            info.regidx     = offset;
            return emit_mul(m_Sink, reg, offset, left, right);
        }
        return true;
    }

    /**
     * Compiles a conditional operator.
     *
     * \param [in]      cond        The node representing the operation.
     * \param [in]      pEnv        The current environment.
     * \param [out]     info        Information about the generated expression.
     * \param [in]      reg         The register to store the result in, or VM_ANY_REGISTER
     *                              if a new temporary register needs to be allocated.
     * \param [in]      offset      Element offset in register, tells us where to store the result
     *                              of a scalar component.
     */
    bool Codegen::Compile(const Node_Conditional & cond, Environment * pEnv, ExpInfo & info, VM_Register_t reg, int offset)
    {
        // compile the compare expression
        ExpInfo cmp, firstExp, secondExp;

        if (!Compile(cond.m_pComp.get(), pEnv, cmp)) {
            return false;
        }

        if (!Compile(cond.m_pFirst.get(), pEnv, firstExp) || !Compile(cond.m_pSecond.get(), pEnv, secondExp)) {
            return false;
        }
        if (reg == VM_ANY_REGISTER) {
            reg = NextTemporary(pEnv);
            info.isreusable = 1;
        }
        info.reg        = reg;
        info.regidx     = offset;
        return emit_cond_assign(m_Sink, reg, offset, firstExp, secondExp);
    }

    /**
     * Compiles a compare operation.
     */
    bool Codegen::Compile(const Node_Comparison & cond, Environment * pEnv)
    {
        ExpInfo left, right;
        if (!Compile(cond.m_pLeft.get(), pEnv, left) ||  !Compile(cond.m_pRight.get(), pEnv, right)) {
            return false;
        }

        switch(cond.m_Type) {
        case Node_Comparison::Op_Equal:         return emit_equal(m_Sink, left, right);
        case Node_Comparison::Op_Greater:       return emit_greater(m_Sink, left, right);
        case Node_Comparison::Op_Less:          return emit_less(m_Sink, left, right);
        case Node_Comparison::Op_GreaterEqual:  return emit_greater_equal(m_Sink, left, right);
        case Node_Comparison::Op_LessEqual:     return emit_less_equal(m_Sink, left, right);
        default:                                return false;
        }
    }

    /**
     * Compiles a constant expression node.
     */
    bool Codegen::Compile(const Node_Constant & constant, Environment * pEnv, ExpInfo & info, VM_Register_t reg,int offset)
    {
        info.isconst    = 1;
        info.type       = constant.m_expType;
        info.isuniform  = 0;
        info.value      = constant.m_Value;
        info.isreusable = 0;
        return true;
    }

    /**
     * Retrives the information required for accessing a variable.
     *
     * Note: Does not generate any actual code.
     */
    bool Codegen::Compile(const Node_Identifier & ident, Environment * pEnv, ExpInfo & info, VM_Register_t reg, int offset)
    {
        vf::Variable var;
        if (!pEnv->Lookup(ident.m_SymIndex, var)) {
            return false;
        }

        info.type           = var.m_Type;
        info.regidx         = 0;
        info.isuniform      = (var.m_Attribute == ATTRIBUTE_UNIFORM) ? 1 : 0;
        info.isreusable     = 0;
        info.isaccumulated  = var.m_Accumulated;

        if (info.isuniform) {
            /** This is a uniform variable, check if the value is known */
            info.isconst = GetUniform(ident.m_SymIndex, info.value);
            if (!info.isconst) {
                /** we don't know the value of this uniform variable, this means that the variable is set
                    just before execution, which prevents us from performing constant folding etc. */
                info.uniform_index = var.m_UniformIndex;
            } else {
                info.isuniform = 0; /** not uniform anymore */
            }
        } else if (var.m_Attribute == ATTRIBUTE_CONST) {
            /** A constant variable which we know the value of, this allows to to perform constant folding,
                the actual value is stored in the const table */
            info.isconst    = 1;
            info.value      = var.m_Value;
        } else {
            /** A variable that is located in a register */
            info.reg    = var.m_Register;
        }

        return true;
    }

    /**
     * Retrives the information required for accessing a member variable of a vector.
     * 
     * Note: Does not generate any actual code.
     */
    bool Codegen::Compile(const Node_MemberReference & ref, Environment * pEnv, ExpInfo & info, VM_Register_t reg, int offset)
    {
        vf::Variable var;
        if (pEnv->Lookup(ref.m_SymIndex, var) == nullptr) {
            return false;
        }

        info.type       = ref.m_MemberType;
        info.isuniform  = (var.m_Attribute == ATTRIBUTE_UNIFORM) ? 1 : 0;
        info.regidx     = ref.m_MemberOffset;
        info.isreusable = 0;

        if (info.isuniform) {
            /** This is a uniform variable */
            info.isconst = GetUniform(ref.m_SymIndex, info.value);
            if (!info.isconst) {
                /** we don't know the value of this uniform variable, this means that the variable is set
                    just before execution, which prevents us from performing constant folding etc. */
                info.uniform_index = var.m_UniformIndex;
            }
        } else {
            info.reg        = var.m_Register;
        }
        return true;
    }


    /**************************************************************************/
    /*                                  Builtin functions                     */
    /**************************************************************************/

    /**
     * dot(u,v) - Dot product of two vectors.
     *
     * Compiles a dot product to a Virtual Machine (VM) instruction.
     */
    bool Codegen::Compile(const Node_DotProduct & product, Environment * pEnv, ExpInfo & info, VM_Register_t reg, int offset)
    {
        ExpInfo first, second;
        if (!Compile(product.m_exp1.get(), pEnv, first) || !Compile(product.m_exp2.get(), pEnv, second)) {
            return false;
        }
        if (first.type != second.type) {
            return false;
        }
        if (reg == VM_ANY_REGISTER) {
            reg = first.isreusable ? first.reg : (second.isreusable ? second.reg : NextTemporary(pEnv));
            info.isreusable = 1;
        }
        info.reg    = reg;
        info.regidx = offset;
        info.type   = vf::Type_Float;

        return emit_dot(m_Sink, reg, offset, first, second);
    }

    /**
     * cross(u, v) - Cross product of two vectors.
     *
     * Compiles a cross product to a Virtual Machine (VM) instruction.
     */
    bool Codegen::Compile(const Node_CrossProduct & product, Environment * pEnv, ExpInfo & info, VM_Register_t reg, int offset)
    {
        ExpInfo first, second;
        if (!Compile(product.m_exp1.get(), pEnv, first) || !Compile(product.m_exp2.get(), pEnv, second)) {
            return false;
        }
        if ((first.type != vf::Type_Vec3) || (second.type != vf::Type_Vec3)) {
            return false;
        }
        if (reg == VM_ANY_REGISTER) {
            reg = first.isreusable ? first.reg : (second.isreusable ? second.reg : NextTemporary(pEnv));
        }

        info.reg    = reg;
        info.regidx = 0;
        info.type   = vf::Type_Vec3;
        return emit_cross(m_Sink, reg, offset, first, second);
    }

    /**
     * length(u) - Length of a vector.
     *
     * Compiles a vector length operation to a Virtual Machine (VM) instruction.
     */
    bool Codegen::Compile(const Node_Length & len, Environment * pEnv, ExpInfo & info, VM_Register_t reg, int offset)
    {
        ExpInfo first;
        if (!Compile(len.m_exp.get(), pEnv, first)) {
            return false;
        }
        if (reg == VM_ANY_REGISTER) {
            reg = first.isreusable ? first.reg : NextTemporary(pEnv);
        }
        info.reg    = reg;
        info.regidx = offset;
        info.type   = vf::Type_Float;
        return emit_length(m_Sink, reg, offset, first);
    }

    /**
     * sin(f)
     *
     * Compiles a sine operation to a Virtual Machine (VM) instruction.
     */
    bool Codegen::Compile(const Node_Sine & sine, Environment * pEnv, ExpInfo & info, VM_Register_t reg, int offset)
    {
        ExpInfo first;
        if (!Compile(sine.m_pExp.get(), pEnv, first)) {
            return false;
        }
        if (first.isconst) {
            info.type       = Type_Float;
            info.isconst    = 1;
            info.value.u.f  = sinf(first.value.u.f);
            return true;
        }
        if (reg == VM_ANY_REGISTER) {
            reg = first.isreusable ? first.reg : NextTemporary(pEnv);
            info.isreusable = 1;
        }
        info.reg    = reg;
        info.regidx = offset;
        info.type   = vf::Type_Float;
        return emit_sine(m_Sink, reg, offset, first);
    }

    /**
     * cos(f)
     *
     * Compiles a cosine operation to a Virtual Machine (VM) instruction.
     */
    bool Codegen::Compile(const Node_Cosine & cosine, Environment * pEnv, ExpInfo & info, VM_Register_t reg, int offset)
    {
        ExpInfo first;
        if (!Compile(cosine.m_pExp.get(), pEnv, first)) {
            return false;
        }
        if (first.isconst) {
            info.type       = Type_Float;
            info.isconst    = 1;
            info.value.u.f  = cosf(first.value.u.f);
            return true;
        }
        if (reg == VM_ANY_REGISTER) {
            reg = first.isreusable ? first.reg : NextTemporary(pEnv);
            info.isreusable = 1;
        }
        info.reg    = reg;
        info.regidx = offset;
        info.type   = vf::Type_Float;
        return emit_cosine(m_Sink, reg, offset, first);
    }

    /**
     * tan(f)
     *
     * Compiles a tangent operation to a Virtual Machine (VM) instruction.
     */
    bool Codegen::Compile(const Node_Tangent & tangent, Environment * pEnv, ExpInfo & info, VM_Register_t reg, int offset)
    {
        ExpInfo first;
        if (!Compile(tangent.m_pExp.get(), pEnv, first)) {
            return false;
        }
        if (first.isconst) {
            info.type       = Type_Float;
            info.isconst    = 1;
            info.value.u.f  = tanf(first.value.u.f);
            return true;
        }
        if (reg == VM_ANY_REGISTER) {
            reg = first.isreusable ? first.reg : NextTemporary(pEnv);
        }
        info.reg    = reg;
        info.regidx = offset;
        info.type   = vf::Type_Float;

        return emit_tangent(m_Sink, reg, offset, first);
    }

    /*************************************************************************/
    /*                                  Arc functions                        */
    /*************************************************************************/
    /**
     * acos(f)
     *
     * Compiles a cosine operation to a Virtual Machine (VM) instruction.
     */
    bool Codegen::Compile(const Node_ArcCosine & arccosine, Environment * pEnv,ExpInfo & info,VM_Register_t reg, int offset)
    {
        ExpInfo first;
        if (!Compile(arccosine.m_pExp.get(), pEnv, first)) {
            return false;
        }
        if (first.isconst) {
            info.type       = Type_Float;
            info.isconst    = 1;
            info.value.u.f  = acosf(first.value.u.f);
            return true;
        }
        if (reg == VM_ANY_REGISTER) {
            reg = first.isreusable ? first.reg : NextTemporary(pEnv);
            info.isreusable = 1;
        }
        info.reg    = reg;
        info.regidx = offset;
        info.type   = vf::Type_Float;

        return emit_arccosine(m_Sink, reg, offset, first);
    }

    /**
     * asin(f)
     *
     * Compiles a arcsine operation to a Virtual Machine (VM) instruction.
     */
    bool Codegen::Compile(const Node_ArcSine & arcsine, Environment * pEnv, ExpInfo & info, VM_Register_t reg, int offset)
    {
        ExpInfo first;
        if (!Compile(arcsine.m_pExp.get(), pEnv, first)) {
            return false;
        }
        if (first.isconst) {
            info.type       = Type_Float;
            info.isconst    = 1;
            info.value.u.f  = asinf(first.value.u.f);
            return true;
        }
        if (reg == VM_ANY_REGISTER) {
            reg = first.isreusable ? first.reg : NextTemporary(pEnv);
            info.isreusable = 1;
        }
        info.reg    = reg;
        info.regidx = offset;
        info.type   = vf::Type_Float;
        return emit_arcsine(m_Sink, reg, offset, first);
    }

    /**
     * atan(f)
     *
     * Compiles a arctan operation to a Virtual Machine (VM) instruction.
     */
    bool Codegen::Compile(const Node_ArcTangent & arctan, vf::Environment * pEnv, ExpInfo & info, VM_Register_t reg, int offset)
    {
        ExpInfo first;
        if (!Compile(arctan.m_pExp.get(), pEnv, first)) {
            return false;
        }
        if (first.isconst) {
            info.type       = Type_Float;
            info.isconst    = 1;
            info.value.u.f  = atanf(first.value.u.f);
            return true;
        }
        if (reg == VM_ANY_REGISTER) {
            reg = first.isreusable ? first.reg : NextTemporary(pEnv);
            info.isreusable = 1;
        }
        info.reg    = reg;
        info.regidx = offset;
        info.type   = vf::Type_Float;
        return emit_arctangent(m_Sink, reg, offset, first);
    }

    /** Negation */
    bool Codegen::Compile(const Node_Negate & negation, Environment * pEnv, ExpInfo & info, VM_Register_t reg, int offset)
    {
        ExpInfo first;
        if (!Compile(negation.m_pExp.get(), pEnv, first)) {
            return false;
        }
        if (first.isconst) {
            switch(first.type) {
            case vf::Type_Float:    info.value.u.f = -first.value.u.f; break;
            case vf::Type_Vec2:     info.value.u.v2 = -first.value.u.v2; break;
            case vf::Type_Vec3:     info.value.u.v3 = -first.value.u.v3; break;
            case vf::Type_Vec4:     info.value.u.v4 = -first.value.u.v4; break;
            }
            info.isconst    = 1;
            info.type       = first.type;
            return true;
        }
        if (reg == VM_ANY_REGISTER) {
            reg = first.isreusable ? first.reg : NextTemporary(pEnv);
            info.isreusable = 1;
        }
        info.reg    = reg;
        info.regidx = offset;
        info.type   = first.type;
        return emit_negate(m_Sink, reg, offset, first);
    }

    /**
     * sqrt(f)
     *
     * Compiles a sqrt operation to a Virtual Machine (VM) instruction.
     */
    bool Codegen::Compile(const Node_Sqrt & op,Environment * pEnv,ExpInfo & info,VM_Register_t reg, int offset)
    {
        ExpInfo first;
        if (!Compile(op.m_pExp.get(), pEnv, first)) {
            return false;
        }
        if (first.isconst) {
            info.type       = Type_Float;
            info.isconst    = 1;
            info.value.u.f  = sqrtf(first.value.u.f);
            return true;
        }
        if (reg == VM_ANY_REGISTER) {
            reg = first.isreusable ? first.reg : NextTemporary(pEnv);
            info.isreusable = 1;
        }
        info.reg    = reg;
        info.regidx = offset;
        info.type   = vf::Type_Float;
        return emit_sqrt(m_Sink, reg, offset, first);
    }

    /**
     * invsqrt(f)
     *
     * Compiles a invsqrt operation to a Virtual Machine (VM) instruction.
     */
    bool Codegen::Compile(const Node_InvSqrt & op, Environment * pEnv, ExpInfo & info, VM_Register_t reg, int offset)
    {
        ExpInfo first;
        if (!Compile(op.m_pExp.get(), pEnv, first)) {
            return false;
        }
        if (first.isconst) {
            info.type       = Type_Float;
            info.isconst    = 1;
            info.value.u.f  = 1.0f / sqrt(first.value.u.f);
            return true;
        }
        if (reg == VM_ANY_REGISTER) {
            reg = first.isreusable ? first.reg : NextTemporary(pEnv);
            info.isreusable = 1;
        }
        info.reg    = reg;
        info.regidx = offset;
        info.type   = vf::Type_Float;
        return emit_invsqrt(m_Sink, reg, offset, first);
    }

    /** Vector normalization */
    bool Codegen::Compile(const Node_Normalize & normalize, Environment * pEnv, ExpInfo & info, VM_Register_t reg, int offset)
    {
        ExpInfo first;
        if (!Compile(normalize.m_pExp.get(), pEnv, first)) {
            return false;
        }
        if (first.isconst) {
            switch(first.type) {
            case vf::Type_Vec2:     info.value.u.v2 = first.value.u.v2.normalize(); break;
            case vf::Type_Vec3:     info.value.u.v3 = first.value.u.v3.normalize(); break;
            case vf::Type_Vec4:     info.value.u.v4 = first.value.u.v4.normalize(); break;
            default:                return false;
            }
            info.isconst    = 1;
            info.type       = first.type;
            return true;
        }

        if (reg == VM_ANY_REGISTER) {
            reg = first.isreusable ? first.reg : NextTemporary(pEnv);
            info.isreusable = 1;
        }
        info.reg    = reg;
        info.regidx = offset;
        info.type   = first.type;
        return emit_normalize(m_Sink, reg, offset, first);
    }

    /**
     * Min/Max
     */
    bool Codegen::Compile(const Node_MinMax & minmax, Environment * pEnv, ExpInfo & info, VM_Register_t reg, int offset)
    {
        ExpInfo first, second;
        if (!Compile(minmax.m_pExp1.get(), pEnv, first) || !Compile(minmax.m_pExp2.get(), pEnv, second)) {
            return false;
        }

        info.isconst = (first.isconst && second.isconst);
        if (info.isconst) {
            switch(first.type) {
            case vf::Type_Float:
                info.value.u.f = (minmax.m_IsMin ? std::min(first.value.u.f, second.value.u.f) : 
                    std::max(first.value.u.f, second.value.u.f));
                break;
            case vf::Type_Vec2:
                minmax.m_IsMin ? vf::Min(info.value.u.v2, first.value.u.v2, second.value.u.v2) :
                    vf::Max(info.value.u.v2, first.value.u.v2, second.value.u.v2);
                break;
            case vf::Type_Vec3:
                minmax.m_IsMin ? vf::Min(info.value.u.v3, first.value.u.v3, second.value.u.v3) :
                    vf::Max(info.value.u.v3, first.value.u.v3, second.value.u.v3);
                break;
            case vf::Type_Vec4:
                minmax.m_IsMin ? vf::Min(info.value.u.v4, first.value.u.v4, second.value.u.v4) :
                    vf::Max(info.value.u.v4, first.value.u.v4, second.value.u.v4);
                break;
            }
            info.type = first.type;
            return true;
        }
        if (reg == VM_ANY_REGISTER) {
            reg = first.isreusable ? first.reg : NextTemporary(pEnv);
            info.isreusable = 1;
        }
        info.reg    = reg;
        info.regidx = offset;
        info.type   = first.type;

        return minmax.m_IsMin ? emit_min(m_Sink, reg, offset, first, second) : 
            emit_max(m_Sink, reg, offset, first, second);
    }

    /**
     * sample1D(), sample2D(), sample3D()
     */
    bool Codegen::Compile(const Node_Sampler & sampler, Environment * pEnv, ExpInfo & info, VM_Register_t reg, int offset)
    {
        ExpInfo exp;
        if (!Compile(sampler.m_pExp.get(), pEnv, exp)) {
            return false;
        }
        Variable var;
        if (!pEnv->Lookup(sampler.m_pIdent->m_SymIndex, var)) {
            return false;
        }
        if (var.m_Type != Type_Sampler) {
            return false;
        }
        if (reg == VM_ANY_REGISTER) {
            reg = (exp.isreusable ? exp.reg : NextTemporary(pEnv));
            info.isreusable = 1;
        }
        info.reg    = reg;
        info.regidx = 0;
        info.type   = Type_Vec4;
        return emit_sample(m_Sink, reg, offset, var.m_SampleId, exp);
    }

    /**
     * Floor/Ceil
     */
    bool Codegen::Compile(const Node_FloorCeil & fc, Environment * pEnv, ExpInfo & info, VM_Register_t reg, int offset)
    {
        ExpInfo exp;
        if (!Compile(fc.m_pExp.get(), pEnv, exp)) {
            return false;
        }
        info.isconst    = exp.isconst;
        info.type       = exp.type;
        if (exp.isconst) {
            switch(exp.type) {
            case vf::Type_Float:    info.value.u.f = fc.m_IsFloor ? floorf(exp.value.u.f) : ceilf(exp.value.u.f); break;
            case vf::Type_Vec2:     
                if (fc.m_IsFloor) {
                    vf::Floor(info.value.u.v2, exp.value.u.v2); break;
                } else {
                    vf::Ceil(info.value.u.v2, exp.value.u.v2); break;
                }
            case vf::Type_Vec3:
                if (fc.m_IsFloor) {
                    vf::Floor(info.value.u.v3, exp.value.u.v3); break;
                } else {
                    vf::Ceil(info.value.u.v3, exp.value.u.v3); break;
                }
            case vf::Type_Vec4:
                if (fc.m_IsFloor) {
                    vf::Floor(info.value.u.v3, exp.value.u.v3); break;
                } else {
                    vf::Ceil(info.value.u.v3, exp.value.u.v3); break;
                }
            default:
                return false;
            }
        } 

        if (reg == VM_ANY_REGISTER) {
            reg = exp.isreusable ? exp.reg : NextTemporary(pEnv);
            info.isreusable = 1;
        }
        info.reg    = reg;
        info.regidx = offset;
        return fc.m_IsFloor ? emit_floor(m_Sink, reg, offset, exp) :  emit_ceil(m_Sink, reg, offset, exp);
    }
}